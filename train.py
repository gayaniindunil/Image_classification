import numpy as np
import os
os.environ["THEANO_FLAGS"] = "mode=FAST_RUN,device=gpu,floatX=float32"
import json
import keras
from keras.models import load_model
from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import ModelCheckpoint
import matplotlib.pyplot as plt
import sys
sys.path.insert(0, 'models/model3')
import model3
from model_input import model_input

#load the config file
with open('conf.json') as f:
    config = json.load(f)

#config variables
dataset = config["dataset"]
train_dir = dataset["train_dir"]
validation_dir = dataset["validation_dir"]

parameters = config["hyperparameters"]
batch_size = parameters["batch_size"]
learning_rate = parameters["learning_rate"]
epochs = parameters["epochs"]
data_augmentation = parameters["data_augmentation"]

model = config["model"]
model_name = model["model_name"]
model_dir = model["model_dir"]
model_save_dir = model["model_save_dir"]
model_save_name = model["model_save_name"]

m = model_save_dir.encode('ascii','ignore')
model_save_dir = os.path.join(os.getcwd(),m)

#load data
(x_train, y_train), (x_test, y_test) = model_input()
num_classes = 10
# Convert class vectors to binary class matrices.
y_train = keras.utils.to_categorical(y_train, num_classes)
y_test = keras.utils.to_categorical(y_test, num_classes)

#load model
model = model3.model(input_shape=x_train.shape[1:],num_classes = num_classes)

# initiate RMSprop optimizer
opt = keras.optimizers.rmsprop(lr=0.0001, decay=1e-6)

# Let's train the model using RMSprop
model.compile(loss='categorical_crossentropy',
              optimizer=opt,
              metrics=['accuracy'])

x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
x_train /= 255
x_test /= 255

if not data_augmentation:
    print "[INFO] Not Use Data Augmantation.."
    hist = model.fit(x_train, y_train,
                batch_size = batch_size,
                epochs = epochs,
                validation_data = (x_test,y_test),
                shuffle = False)
else:
    print "[INFO] Using Real Time Data Augmantation..."
    datagen = ImageDataGenerator(
        featurewise_center=False,  # set input mean to 0 over the dataset
        samplewise_center=False,  # set each sample mean to 0
        featurewise_std_normalization=False,  # divide inputs by std of the dataset
        samplewise_std_normalization=False,  # divide each input by its std
        zca_whitening=False,  # apply ZCA whitening
        rotation_range=0,  # randomly rotate images in the range (degrees, 0 to 180)
        width_shift_range=0.1,  # randomly shift images horizontally (fraction of total width)
        height_shift_range=0.1,  # randomly shift images vertically (fraction of total height)
        horizontal_flip=True,  # randomly flip images
        vertical_flip=False)  # randomly flip images

    # Compute quantities required for feature-wise normalization
    # (std, mean, and principal components if ZCA whitening is applied).
    datagen.fit(x_train)

    #model checkpoints
    filepath= model_save_dir + "/weights-improvement-{epoch:02d}-{val_acc:.2f}.hdf5"
    checkpoint = ModelCheckpoint(filepath, monitor='val_acc', verbose=1, save_best_only=True, mode='max')
    callbacks_list = [checkpoint]

    # Fit the model on the batches generated by datagen.flow().
    hist = model.fit_generator(datagen.flow(x_train, y_train,batch_size=batch_size),
                            steps_per_epoch=x_train.shape[0] // batch_size,
                            epochs=epochs,
                            validation_data=(x_test, y_test),
                            callbacks=callbacks_list)


#save trained model
model_path = os.path.join(model_save_dir,model_save_name)
model.save(model_path)
print ("[INFO] model saved at %s" %model_path)
#plot graphs of the trained model
train_loss = hist.history['loss']
train_acc = hist.history['acc']
val_loss = hist.history['val_loss']
val_acc = hist.history['val_acc']

# print("train_loss: %s" %(train_loss))
# print("train_acc: %s" %(train_acc))
# print("val_loss: %s" %(val_loss))
# print("val_acc: %s" %(val_acc))

fig = plt.figure()
xc = range(epochs)
plt.plot(xc,train_acc,xc,val_acc)
plt.ylabel('Accuracy')
plt.xlabel('Epochs')
plt.show()
